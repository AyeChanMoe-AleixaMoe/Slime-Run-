<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Endless Runner — 2D Subway Surfers Style</title>
  <style>
    :root{
      --bg:#0e1323;         /* deep indigo */
      --fg:#e6edf3;         /* light text */
      --accent:#7aa2ff;     /* hud */
      --danger:#ff6b6b;     /* fireball / flame */
      --warning:#ffcc66;    /* spikes */
      --ground:#1b2142;     /* ground line */
      --platform:#2c3463;   /* floating platforms */
      --player:#4be4c9;     /* player color */
      --pipe:#6b7280;       /* fire pipe */
    }
    html,body{height:100%; margin:0; background:var(--bg); color:var(--fg); font-family:system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, sans-serif}
    #wrap{display:grid; place-items:center; height:100%;}
    canvas{background:linear-gradient(180deg, #0d1327 0%, #11183a 60%, #0d1327 100%);
           box-shadow:0 10px 40px rgba(0,0,0,.5); border-radius:14px; max-width:100vw; max-height:100vh}
    .hud{position:fixed; inset:12px 12px auto auto; display:flex; gap:12px; align-items:center;}
    .hud .pill{background:rgba(255,255,255,.06); border:1px solid rgba(255,255,255,.12); padding:8px 12px; border-radius:999px; font-weight:600}
    .help{position:fixed; left:12px; bottom:12px; background:rgba(255,255,255,.06); border:1px solid rgba(255,255,255,.12); border-radius:12px; padding:10px 12px; line-height:1.5}
    .help kbd{background:#1f254d; border:1px solid #353c78; border-bottom-width:3px; padding:2px 6px; border-radius:6px; font-weight:700}
    .overlay{position:fixed; inset:0; display:grid; place-items:center; pointer-events:none}
    .overlay.active{pointer-events:auto}
    .banner{background:rgba(14,19,35,.75); border:1px solid rgba(255,255,255,.12); padding:18px 22px; border-radius:14px; text-align:center; backdrop-filter: blur(6px)}
    .banner h1{margin:0 0 10px; font-size:20px}
    .banner p{margin:6px 0}
    .btn{background:rgba(255,255,255,.08); border:1px solid rgba(255,255,255,.2); color:var(--fg); padding:8px 14px; border-radius:10px; cursor:pointer; font-weight:700}
    .btn:hover{background:rgba(255,255,255,.15)}
  </style>
</head>
<body>
  <div id="wrap">
    <canvas id="game" width="1024" height="576" aria-label="Endless Runner Game"></canvas>
  </div>

  <div class="hud" aria-hidden="true">
    <div class="pill" id="scorePill">0 m</div>
    <div class="pill" id="hiPill">HI 0 m</div>
    <div class="pill" id="speedPill">Speed 0</div>
  </div>

  <div class="help" aria-hidden="true">
    <div><strong>Controls</strong></div>
    <div><kbd>Space</kbd>/<kbd>↑</kbd> Jump · <kbd>C</kbd>/<kbd>Ctrl</kbd>/<kbd>↓</kbd> Crouch (fast-fall in air)</div>
    <div><kbd>P</kbd> Pause/Resume · <kbd>R</kbd> Restart</div>
  </div>

  <div class="overlay" id="overlay" aria-live="polite"></div>

  <script>
  // ======= CONFIG =======
  const CONFIG = {
    gravity: 2000,
    jumpVelocity: 900,
    maxCoyoteTime: 90,            // ms
    baseGroundY: 520,
    topClampY: 48,                // keep player on screen
    startSpeed: 300,
    maxSpeed: 1200,
    speedRampPerSec: 16,
    spawn: {
      obstacleBaseEvery: 1.2,
      platformBaseEvery: 1.6,
      platformProb: 0.55,
      obstacleProb: 0.9,
      pipeProb: 0.22,
      bounceBoulderProb: 0.35
    },
    terrain: {
      flatProb: 0.55,
      upSlopeProb: 0.20,
      downSlopeProb: 0.18,
      holeProb: 0.07,
      minW: 260, maxW: 540,
      maxRise: 110,
      minY: 420, maxY: 540
    },
    player: {
      w: 46, h: 72,
      crouchH: 40,
      x: 200,
      invulnBlinkMs: 100,
      maxAirTime: 1.0,
      holdGravityFactor: 0.35,
      jumpCutFactor: 0.45,
      fastFallMultiplier: 2.4,
      slimeRiseStretch: 0.20,
      slimeFallSquash: 0.25,
      slimeLerpRate: 10,
      bonkSquashX: 1.25,
      bonkSquashY: 0.78,
      bonkDuration: 0.18
    },
    fireball: {
      radius: 18,
      wobbleAmp: 12,
      wobbleFreq: 4,
      color: getComputedStyle(document.documentElement).getPropertyValue('--danger').trim() || '#ff6b6b'
    },
    spike: {
      base: 38, height: 36,
      color: getComputedStyle(document.documentElement).getPropertyValue('--warning').trim() || '#ffcc66'
    },
    boulder: {
      rMin: 16, rMax: 22,
      minBounceH: 100,
      maxBounceH: 150,
      driftMin: 120,
      driftMax: 220
    },
    rollBoulder: { r: 22, rollBoost: 200 },
    platform: {
      minW: 120, maxW: 260,
      minY: 260, maxY: 420,
      thickness: 12,
      color: getComputedStyle(document.documentElement).getPropertyValue('--platform').trim() || '#2c3463',
      underSpikeHeight: 22,
      topSpikeHeight: 18,
      step: 14,
      topDist:   { none: 0.45, few: 0.40, full: 0.15 },
      underDist: { none: 0.50, few: 0.35, full: 0.15 },
      fewMin: 1, fewMax: 3
    },
    pipe: {
      w: 26, h: 16,
      flameW: 16, minFlame: 90, maxFlame: 160,
      onTime: 0.55, cooldown: 1.0,
      color: getComputedStyle(document.documentElement).getPropertyValue('--pipe').trim() || '#6b7280',
      fadeRate: 10
    }
  };

  // ======= UTIL =======
  const clamp = (v, a, b)=> Math.max(a, Math.min(b, v));
  function rectsOverlap(a,b){ return !(a.x+a.w <= b.x || a.x >= b.x+b.w || a.y+a.h <= b.y || a.y >= b.y+b.h); }
  function circleRectCollide(cx, cy, r, rx, ry, rw, rh){
    const nx = clamp(cx, rx, rx+rw); const ny = clamp(cy, ry, ry+rh);
    const dx = cx - nx, dy = cy - ny; return (dx*dx + dy*dy) <= r*r;
  }
  function roundRectPath(g, x, y, w, h, r){
    r = Math.min(r, w/2, h/2);
    g.beginPath();
    g.moveTo(x+r, y);
    g.arcTo(x+w, y,   x+w, y+h, r);
    g.arcTo(x+w, y+h, x,   y+h, r);
    g.arcTo(x,   y+h, x,   y,   r);
    g.arcTo(x,   y,   x+w, y,   r);
    g.closePath();
  }
  const randInt=(a,b)=> (a+Math.floor(Math.random()*(b-a+1)));
  const randRange=(a,b)=> (a + Math.random()*(b-a));

  // ======= INPUT =======
  const input = { up:false, down:false, crouch:false, pause:false, restart:false };
  addEventListener('keydown', e=>{
    if(['Space','ArrowUp','KeyW'].includes(e.code)){ input.up=true; e.preventDefault(); }
    if(['ArrowDown','ControlLeft','ControlRight','KeyC'].includes(e.code)){ input.down=true; input.crouch=true; e.preventDefault(); }
    if(e.code==='KeyP'){ input.pause = true; }  // handled in frame loop
    if(e.code==='KeyR'){ input.restart = true; }
  });
  addEventListener('keyup', e=>{
    if(['Space','ArrowUp','KeyW'].includes(e.code)){ input.up=false; }
    if(['ArrowDown','ControlLeft','ControlRight','KeyC'].includes(e.code)){ input.down=false; input.crouch=false; }
  });

  // ======= GAME STATE =======
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const scorePill = document.getElementById('scorePill');
  const hiPill = document.getElementById('hiPill');
  const speedPill = document.getElementById('speedPill');
  const overlay = document.getElementById('overlay');

  const HI_KEY = 'endlessRunnerHiScoreV1';
  let hiScore = Number(localStorage.getItem(HI_KEY) || 0);
  hiPill.textContent = `HI ${hiScore} m`;

  function fitCanvas(){
    const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    const styleW = Math.min(innerWidth-24, 1024);
    const styleH = Math.min(innerHeight-24, 576);
    const ar = 1024/576; let w=styleW, h=styleW/ar; if(h>styleH){ h=styleH; w=h*ar; }
    canvas.style.width = w+'px'; canvas.style.height=h+'px';
    canvas.width = Math.round(w*dpr); canvas.height = Math.round(h*dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0);
    ctx.imageSmoothingEnabled = true;
  }
  addEventListener('resize', fitCanvas); fitCanvas();

  // ======= TERRAIN =======
  class Segment{
    constructor(x, w, y0, y1, kind='solid'){ this.x=x; this.w=w; this.y0=y0; this.y1=y1; this.kind=kind; }
    get slope(){ return (this.y1 - this.y0)/this.w; }
    yAt(px){ const t = clamp((px - this.x)/this.w, 0, 1); return this.y0 + (this.y1 - this.y0) * t; }
    right(){ return this.x + this.w; }
    update(dt, speed){ this.x -= speed*dt; }
    draw(g){
      if(this.kind==='hole') return;
      g.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--ground').trim() || '#1b2142';
      g.lineWidth = 4; g.beginPath(); g.moveTo(this.x, this.y0+2); g.lineTo(this.x+this.w, this.y1+2); g.stroke();
    }
  }

  // ======= PLATFORM HELPERS =======
  function buildSpikeOffsets(width, step, pattern, fewMin, fewMax){
    const offsets = [];
    const cells = Math.max(1, Math.floor(width / step));
    if(pattern === 'none') return offsets;
    if(pattern === 'full'){ for(let i=0;i<cells;i++) offsets.push(i*step); return offsets; }
    const n = randInt(fewMin, Math.min(fewMax, cells));
    const taken = new Set();
    while(taken.size < n) taken.add(randInt(0, cells-1));
    for(const c of taken) offsets.push(c*step);
    return offsets;
  }
  function choosePattern(dist){
    const r = Math.random();
    if(r < dist.none) return 'none';
    if(r < dist.none + dist.few) return 'few';
    return 'full';
  }

  class Platform{
    constructor(x,w,y){
      this.x=x; this.w=w; this.y=y; this.h=CONFIG.platform.thickness;
      this.topPattern   = choosePattern(CONFIG.platform.topDist);
      this.underPattern = choosePattern(CONFIG.platform.underDist);
      const {step, fewMin, fewMax} = CONFIG.platform;
      this.topOffsets   = buildSpikeOffsets(this.w, step, this.topPattern,   fewMin, fewMax);
      this.underOffsets = buildSpikeOffsets(this.w, step, this.underPattern, fewMin, fewMax);
    }
    get rect(){ return {x:this.x, y:this.y, w:this.w, h:this.h}; }
    update(dt,speed){ this.x -= speed*dt; }
    topHazardRects(){ const rs=[]; const step=CONFIG.platform.step, th=CONFIG.platform.topSpikeHeight;
      for(const off of this.topOffsets) rs.push({x:this.x+off, y:this.y - th, w:step, h:th}); return rs; }
    underHazardRects(){ const rs=[]; const step=CONFIG.platform.step, sh=CONFIG.platform.underSpikeHeight;
      for(const off of this.underOffsets) rs.push({x:this.x+off, y:this.y, w:step, h:sh}); return rs; }
    draw(g){
      g.fillStyle = CONFIG.platform.color; g.fillRect(this.x, this.y, this.w, this.h);
      const step = CONFIG.platform.step;
      if(this.topOffsets.length){
        const th = CONFIG.platform.topSpikeHeight; g.fillStyle = CONFIG.spike.color;
        for(const off of this.topOffsets){
          const x = this.x + off;
          g.beginPath(); g.moveTo(x, this.y); g.lineTo(x+step/2, this.y - th); g.lineTo(x+step, this.y); g.closePath(); g.fill();
        }
      }
      if(this.underOffsets.length){
        const sh = CONFIG.platform.underSpikeHeight; g.fillStyle = CONFIG.spike.color;
        for(const off of this.underOffsets){
          const x = this.x + off;
          g.beginPath(); g.moveTo(x, this.y); g.lineTo(x+step/2, this.y + sh); g.lineTo(x+step, this.y); g.closePath(); g.fill();
        }
      }
    }
  }

  // ======= HAZARDS =======
  class Spike{
    constructor(x){ this.w = CONFIG.spike.base; this.h = CONFIG.spike.height; this.x=x; this.y = CONFIG.baseGroundY - this.h; }
    get rect(){ return {x:this.x, y:this.y, w:this.w, h:this.h}; }
    update(dt,speed,world){
      this.x -= speed*dt;
      const gy = world.groundYAt(this.x + this.w/2);
      if(gy !== null) this.y = gy - this.h;
    }
    draw(g){
      g.fillStyle = CONFIG.spike.color;
      g.beginPath(); g.moveTo(this.x, this.y+this.h);
      g.lineTo(this.x+this.w/2, this.y);
      g.lineTo(this.x+this.w, this.y+this.h);
      g.closePath(); g.fill();
    }
  }

  class Fireball{
    constructor(x, baseY){ this.r = CONFIG.fireball.radius; this.x=x; this.baseY=baseY; this.t=0; }
    get y(){ return this.baseY + Math.sin(this.t*CONFIG.fireball.wobbleFreq*2*Math.PI)*CONFIG.fireball.wobbleAmp; }
    get rect(){ return {x:this.x-this.r, y:this.y-this.r, w:this.r*2, h:this.r*2}; }
    update(dt,speed){ this.t+=dt; this.x -= (speed * 1.25 + 120) * dt; }
    draw(g){
      const y = this.y;
      g.beginPath(); g.arc(this.x, y, this.r, 0, Math.PI*2);
      const grd = g.createRadialGradient(this.x, y, 4, this.x, y, this.r);
      grd.addColorStop(0,'#fff1'); grd.addColorStop(0.2,'#fff6'); grd.addColorStop(0.5, CONFIG.fireball.color); grd.addColorStop(1,'#d22');
      g.fillStyle = grd; g.fill();
      g.globalAlpha = 0.22; g.fillStyle = CONFIG.fireball.color;
      g.beginPath(); g.ellipse(this.x+this.r*0.9, y, this.r*1.9, this.r*0.85, 0, 0, Math.PI*2); g.fill(); g.globalAlpha=1;
    }
  }

  class BouncingBoulder{
    constructor(x, y){
      this.r = randInt(CONFIG.boulder.rMin, CONFIG.boulder.rMax);
      this.x = x; this.y = y; this.vy = 0;
      this.drift = randRange(CONFIG.boulder.driftMin, CONFIG.boulder.driftMax);
    }
    get rect(){ return {x:this.x-this.r, y:this.y-this.r, w:this.r*2, h:this.r*2}; }
    update(dt, speed, world){
      this.vy += CONFIG.gravity * dt;
      this.y  += this.vy * dt;
      this.x  -= (speed + this.drift) * dt;
      const gy = world.groundYAt(this.x);
      if(gy !== null && this.y + this.r >= gy){
        this.y = gy - this.r;
        const H = randRange(CONFIG.boulder.minBounceH, CONFIG.boulder.maxBounceH);
        const vyUp = Math.sqrt(2 * CONFIG.gravity * H);
        this.vy = -vyUp;
      }
    }
    draw(g){
      g.beginPath(); g.arc(this.x, this.y, this.r, 0, Math.PI*2);
      const grd = g.createRadialGradient(this.x-this.r*0.3, this.y-this.r*0.3, this.r*0.2, this.x, this.y, this.r);
      grd.addColorStop(0,'#fff6'); grd.addColorStop(0.2,'#bbb'); grd.addColorStop(1,'#666');
      g.fillStyle = grd; g.fill();
    }
  }

  class RollingBoulder{
    constructor(x, y){ this.r = CONFIG.rollBoulder.r; this.x = x; this.y = y; }
    get rect(){ return {x:this.x-this.r, y:this.y-this.r, w:this.r*2, h:this.r*2}; }
    update(dt, speed, world){
      this.x -= (speed + CONFIG.rollBoulder.rollBoost) * dt;
      const gy = world.groundYAt(this.x);
      if(gy !== null) this.y = gy - this.r;
      else { this.y += CONFIG.gravity * dt * dt; }
    }
    draw(g){
      g.beginPath(); g.arc(this.x, this.y, this.r, 0, Math.PI*2);
      g.fillStyle = '#7a7a7a'; g.fill();
      g.fillStyle = '#ffffff55'; g.beginPath(); g.arc(this.x-this.r*0.4, this.y-this.r*0.4, this.r*0.5, 0, Math.PI*2); g.fill();
    }
  }

  class FirePipe{
    constructor(x, flameH){
      this.x = x; this.y = CONFIG.baseGroundY;
      this.w = CONFIG.pipe.w; this.h = CONFIG.pipe.h;
      this.flameH = flameH;
      this.timer = Math.random() * (CONFIG.pipe.onTime + CONFIG.pipe.cooldown);
      this.on = Math.random() < 0.5;
      this.intensity = this.on ? 1 : 0;
      this.anim = 0; this.seed = Math.random()*Math.PI*2;
    }
    baseRect(){ return {x:this.x - this.w/2, y:this.y - this.h, w:this.w, h:this.h}; }
    flameRect(scale=1){
      const frW = CONFIG.pipe.flameW;
      const h = this.flameH * scale;
      return {x:this.x - frW/2, y:this.y - this.h - h, w:frW, h:h};
    }
    update(dt, speed, world){
      this.anim += dt;
      this.x -= speed*dt;
      const gy = world.groundYAt(this.x);
      this.y = (gy !== null) ? gy : CONFIG.baseGroundY;

      this.timer -= dt;
      if(this.on && this.timer <= 0){ this.on = false; this.timer = CONFIG.pipe.cooldown; }
      else if(!this.on && this.timer <= 0){ this.on = true; this.timer = CONFIG.pipe.onTime; }

      const target = this.on ? 1 : 0;
      const k = Math.min(1, CONFIG.pipe.fadeRate*dt);
      this.intensity += (target - this.intensity) * k;
    }
    draw(g){
      const b = this.baseRect();
      g.fillStyle = CONFIG.pipe.color; g.fillRect(b.x, b.y, b.w, b.h);
      g.fillStyle = '#9aa3b2'; g.fillRect(b.x-2, b.y-4, b.w+4, 4);

      if(this.intensity > 0.02){
        const scale = this.intensity;
        const flicker = 0.08 * Math.sin(this.anim*12 + this.seed) + 0.05 * Math.sin(this.anim*7 + this.seed*1.7);
        const h = this.flameH * (0.85 + 0.15*scale) * (1 + flicker);
        const w = CONFIG.pipe.flameW * (0.9 + 0.3*scale * (1 - 0.5*Math.sin(this.anim*9 + this.seed)));

        const x = this.x, baseY = this.y - this.h;
        g.beginPath();
        g.moveTo(x - w*0.5, baseY);
        g.quadraticCurveTo(x - w*0.25, baseY - h*0.45*(1+0.2*Math.sin(this.anim*6+this.seed)),
                           x,           baseY - h);
        g.quadraticCurveTo(x + w*0.25, baseY - h*0.45*(1-0.2*Math.sin(this.anim*5+this.seed*0.9)),
                           x + w*0.5,   baseY);
        g.closePath();

        const grd = g.createLinearGradient(x, baseY-h, x, baseY);
        grd.addColorStop(0,   '#ffe082');
        grd.addColorStop(0.35,'#ffb74d');
        grd.addColorStop(0.7, '#ff6b6b');
        grd.addColorStop(1,   '#b91c1c');
        g.fillStyle = grd;
        g.globalAlpha = clamp(0.3 + 0.7*scale, 0, 1);
        g.fill();
        g.globalAlpha = 1;
      }
    }
  }

  // ======= PLAYER =======
  let FRAME_GROUND_Y = CONFIG.baseGroundY;
  class Player{
    constructor(){
      this.x = CONFIG.player.x; this.y = CONFIG.baseGroundY - CONFIG.player.h;
      this.w = CONFIG.player.w; this.h = CONFIG.player.h;
      this.vy = 0; this.onGround = true; this.onPlatform = null; this.coyoteMs = 0; this.crouched=false;
      this.airTime = 0; this.jumpCutApplied = false;
      this.scaleX = 1; this.scaleY = 1;
      this.bonkTimer = 0;
    }
    get rect(){ return {x:this.x, y:this.y, w:this.w, h:this.h}; }
    update(dt){
      if(this.bonkTimer>0) this.bonkTimer = Math.max(0, this.bonkTimer - dt);

      if(input.crouch){
        if(!this.crouched){
          const dh = this.h - CONFIG.player.crouchH; this.y += dh; this.h = CONFIG.player.crouchH; this.crouched=true;
        }
      }else if(this.crouched && this.onGround){
        const newH = CONFIG.player.h; const dy = newH - this.h;
        this.y -= dy; this.h = newH; this.crouched=false;
      }

      if(input.up && (this.onGround || this.onPlatform || this.coyoteMs>0)){
        this.vy = -CONFIG.jumpVelocity;
        this.onGround=false; this.onPlatform=null; this.coyoteMs=0;
        this.airTime = 0; this.jumpCutApplied = false;
      }

      let g = CONFIG.gravity;
      if(this.vy < 0 && input.up && this.airTime < CONFIG.player.maxAirTime){
        g *= CONFIG.player.holdGravityFactor;
      }else if(!input.up && this.vy < 0 && !this.jumpCutApplied){
        this.vy *= CONFIG.player.jumpCutFactor; this.jumpCutApplied = true;
      }

      if(!this.onGround && !this.onPlatform && input.crouch){ g *= CONFIG.player.fastFallMultiplier; }

      this.vy += g * dt; this.y += this.vy * dt;

      if(this.y < CONFIG.topClampY){ this.y = CONFIG.topClampY; if(this.vy < 0) this.vy = 0; }

      if(FRAME_GROUND_Y !== null && this.y + this.h >= FRAME_GROUND_Y){
        this.y = FRAME_GROUND_Y - this.h; this.vy = 0;
        if(!this.onGround && !this.onPlatform) this.onGround=true;
        this.airTime = 0; this.jumpCutApplied = false;
      }else{
        if(this.onGround){ this.coyoteMs = CONFIG.maxCoyoteTime; }
        this.onGround=false; this.airTime += dt;
        if(this.airTime > CONFIG.player.maxAirTime + 0.02 && this.vy < 600){ this.vy = Math.max(this.vy, 600); }
      }

      if(this.coyoteMs>0 && !(this.onGround||this.onPlatform)){
        this.coyoteMs -= dt*1000; if(this.coyoteMs<0) this.coyoteMs=0;
      }

      let tx=1, ty=1;
      if(this.crouched){ tx=1.15; ty=0.75; }
      else {
        const rise = clamp(-this.vy * 0.0005, 0, CONFIG.player.slimeRiseStretch);
        const fall = clamp(this.vy * 0.0006, 0, CONFIG.player.slimeFallSquash);
        const morph = rise - fall; ty = 1 + morph; tx = 1 - morph;
      }
      if(this.bonkTimer>0){ tx = Math.max(tx, CONFIG.player.bonkSquashX); ty = Math.min(ty, CONFIG.player.bonkSquashY); }
      const k = Math.min(1, CONFIG.player.slimeLerpRate * dt);
      this.scaleX += (tx - this.scaleX) * k;
      this.scaleY += (ty - this.scaleY) * k;
    }
    draw(g){
      g.save();
      g.translate(this.x + this.w/2, this.y + this.h);
      g.scale(this.scaleX, this.scaleY);
      const w = this.w, h = this.h;
      roundRectPath(g, -w/2, -h, w, h, 10);
      g.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--player').trim() || '#4be4c9';
      g.fill();
      g.fillStyle = 'rgba(0,0,0,.25)'; g.fillRect(w/2 - 12, -h + 8, 6, 8);
      g.restore();
    }
  }

  // ======= WORLD =======
  class World{
    constructor(){
      this.reset();
      this.state = 'menu';          // 'menu' | 'playing' | 'paused' | 'dead' | 'credits'
      showMenu(this);               // <-- pass instance, avoid undefined global
    }
    reset(){
      this.player = new Player();
      this.obstacles = [];
      this.platforms = [];
      this.terrain = [];
      this.speed = CONFIG.startSpeed;
      this.meters = 0; this.alive=true; this.time=0; this.spawnTimerObs=0; this.spawnTimerPlat=0; this.freeze=false;

      const W = canvas.clientWidth;
      this.terrain.push(new Segment(-100, W+400, CONFIG.baseGroundY, CONFIG.baseGroundY, 'solid'));
      while(this.terrain[this.terrain.length-1].right() < W+600) this.addSegment();

      const gy = this.groundYAt(this.player.x + this.player.w/2) ?? CONFIG.baseGroundY;
      this.player.y = gy - this.player.h;
    }

    start(){
      this.reset();
      this.state = 'playing';
      overlay.classList.remove('active');
      overlay.innerHTML = '';
    }
    pause(){
      if(this.state!=='playing') return;
      this.state = 'paused';
      setOverlay(`
        <div class="banner">
          <h1>Paused</h1>
          <p><button id="btnResume" class="btn">Resume</button></p>
          <p><button id="btnRestart" class="btn">Restart</button></p>
          <p><button id="btnMenu" class="btn">Main Menu</button></p>
        </div>`, true);
      byId('btnResume').onclick = ()=> this.resume();
      byId('btnRestart').onclick = ()=> { this.start(); };
      byId('btnMenu').onclick = ()=> showMenu(this);
    }
    resume(){
      if(this.state!=='paused') return;
      this.state = 'playing';
      overlay.classList.remove('active');
      overlay.innerHTML = '';
    }

    addSegment(){
      const last = this.terrain[this.terrain.length-1];
      const x = last.right();
      const w = randInt(CONFIG.terrain.minW, CONFIG.terrain.maxW);

      const r = Math.random();
      const inY = last.y1;
      const clampY = y => clamp(y, CONFIG.terrain.minY, CONFIG.terrain.maxY);

      if(r < CONFIG.terrain.holeProb){
        this.terrain.push(new Segment(x, randInt(120, 220), inY, inY, 'hole')); return;
      }
      if(r < CONFIG.terrain.holeProb + CONFIG.terrain.upSlopeProb){
        const dy = -randInt(40, CONFIG.terrain.maxRise);
        const y1 = clampY(inY + dy);
        this.terrain.push(new Segment(x, w, inY, y1, 'solid')); return;
      }
      if(r < CONFIG.terrain.holeProb + CONFIG.terrain.upSlopeProb + CONFIG.terrain.downSlopeProb){
        const dy = randInt(40, CONFIG.terrain.maxRise);
        const y1 = clampY(inY + dy);
        this.terrain.push(new Segment(x, w, inY, y1, 'solid')); return;
      }
      this.terrain.push(new Segment(x, w, inY, inY, 'solid'));
    }

    groundYAt(px){
      for(const seg of this.terrain){
        if(px >= seg.x && px <= seg.right()){
          if(seg.kind==='hole') return null;
          return seg.yAt(px);
        }
      }
      return CONFIG.baseGroundY;
    }
    segmentAtX(px){
      for(const seg of this.terrain){
        if(px >= seg.x && px <= seg.right()) return seg;
      }
      return null;
    }

    spawnObstacle(){
      const x = canvas.clientWidth + 60;
      const seg = this.segmentAtX(x) || this.terrain[this.terrain.length-1];
      const slope = seg.kind==='solid' ? seg.slope : 0;
      const upclineZone = (seg.kind==='solid' && slope < -0.05);
      const gy = this.groundYAt(x);

      if(upclineZone){
        if(Math.random() < 0.6 && gy !== null){
          this.obstacles.push(new RollingBoulder(x, gy - CONFIG.rollBoulder.r));
        }else if(gy !== null){
          this.obstacles.push(new Spike(x - CONFIG.spike.base/2));
        }
        return;
      }

      const roll = Math.random();
      if(roll < CONFIG.spawn.pipeProb && gy !== null){
        const flameH = randInt(CONFIG.pipe.minFlame, CONFIG.pipe.maxFlame);
        this.obstacles.push(new FirePipe(x, flameH));
      }else if(roll < CONFIG.spawn.pipeProb + CONFIG.spawn.bounceBoulderProb){
        const minY = 120, maxY = CONFIG.baseGroundY - 160;
        const y = randInt(minY, maxY);
        this.obstacles.push(new BouncingBoulder(x, y));
      }else{
        if(Math.random() < 0.55 && gy !== null){
          this.obstacles.push(new Spike(x - CONFIG.spike.base/2));
        }else{
          const minY = 200, maxY = (gy ?? CONFIG.baseGroundY) - 120;
          const y = clamp(minY + Math.random()*(maxY-minY), 140, CONFIG.baseGroundY - 140);
          this.obstacles.push(new Fireball(x, y));
        }
      }
    }

    spawnPlatform(){
      const x = canvas.clientWidth + 80;
      const seg = this.segmentAtX(x);
      if(seg && seg.kind==='solid' && seg.slope < -0.05){ return; }

      const w = CONFIG.platform.minW + Math.random()*(CONFIG.platform.maxW - CONFIG.platform.minW);
      const y = CONFIG.platform.minY + Math.random()*(CONFIG.platform.maxY - CONFIG.platform.minY);
      const last = this.platforms[this.platforms.length-1];
      if(last){
        const gap = x - (last.x + last.w);
        if(gap < 120) return;
      }
      this.platforms.push(new Platform(x, w, y));
    }

    handleSpawning(dt){
      const speedFactor = this.speed / CONFIG.startSpeed;
      const obsInterval  = Math.max(0.42, CONFIG.spawn.obstacleBaseEvery / speedFactor);
      const platInterval = Math.max(0.62, CONFIG.spawn.platformBaseEvery / Math.sqrt(speedFactor));
      this.spawnTimerObs  += dt;
      this.spawnTimerPlat += dt;

      if(this.spawnTimerObs >= obsInterval){
        this.spawnTimerObs = 0; if(Math.random() < CONFIG.spawn.obstacleProb) this.spawnObstacle();
      }
      if(this.spawnTimerPlat >= platInterval){
        this.spawnTimerPlat = 0; if(Math.random() < CONFIG.spawn.platformProb) this.spawnPlatform();
      }
    }

    update(dt){
      if(this.state !== 'playing') return;

      this.time += dt;
      this.speed = clamp(this.speed + CONFIG.speedRampPerSec*dt, CONFIG.startSpeed, CONFIG.maxSpeed);
      this.meters += (this.speed * dt) / 50;

      const W = canvas.clientWidth;
      while(this.terrain[this.terrain.length-1].right() < W + 600){ this.addSegment(); }
      for(const seg of this.terrain) seg.update(dt, this.speed);
      this.terrain = this.terrain.filter(s=> s.right() > -200);

      FRAME_GROUND_Y = this.groundYAt(this.player.x + this.player.w/2);

      this.handleSpawning(dt);

      this.player.update(dt);
      for(const p of this.platforms) p.update(dt, this.speed);
      for(const o of this.obstacles){
        if(o instanceof Spike || o instanceof BouncingBoulder || o instanceof RollingBoulder || o instanceof FirePipe){
          o.update(dt, this.speed, this);
        }else{
          o.update(dt, this.speed);
        }
      }

      this.platforms = this.platforms.filter(p=> p.x + p.w > -50);
      this.obstacles = this.obstacles.filter(o=>{
        const right = (o instanceof Spike) ? (o.x + o.w)
                     : (o instanceof Fireball) ? (o.x + o.r)
                     : (o instanceof BouncingBoulder || o instanceof RollingBoulder || o instanceof FirePipe) ? (o.x + 40)
                     : 0;
        return right > -60;
      });

      // Platforms & hazards
      const pl = this.player;
      pl.onPlatform = null;

      for(const pf of this.platforms){
        for(const hr of pf.topHazardRects()){ if(rectsOverlap(pl.rect, hr)) return this.die(); }

        if(pl.vy < 0){
          const headRect = { x: pl.x, y: pl.y, w: pl.w, h: 4 };
          const barRect  = pf.rect;
          if(rectsOverlap(headRect, barRect)){
            let inUnderSpike = false;
            for(const hr of pf.underHazardRects()){ if(rectsOverlap(headRect, hr)) { inUnderSpike=true; break; } }
            if(!inUnderSpike){
              pl.vy = Math.max(pl.vy, 120);
              pl.y  = pf.y + pf.h + 0.1;
              pl.bonkTimer = CONFIG.player.bonkDuration;
            }
          }
        }

        const prevY = pl.y - pl.vy*dt;
        const wasAbove = prevY + pl.h <= pf.y + 2;
        if(rectsOverlap(pl.rect, pf.rect) && wasAbove && pl.vy >= 0){
          pl.y = pf.y - pl.h; pl.vy = 0; pl.onPlatform = pf;
        }

        for(const hr of pf.underHazardRects()){
          if(rectsOverlap(pl.rect, hr) && !pl.crouched){ return this.die(); }
        }
      }

      // Other hazards
      const pr = pl.rect;
      for(const o of this.obstacles){
        if(o instanceof Spike){
          if(rectsOverlap(pr, o.rect)) return this.die();
        }else if(o instanceof Fireball){
          if(circleRectCollide(o.x, o.y, o.r*0.9, pr.x, pr.y, pr.w, pr.h)) return this.die();
        }else if(o instanceof BouncingBoulder || o instanceof RollingBoulder){
          if(circleRectCollide(o.x, o.y, o.r*0.9, pr.x, pr.y, pr.w, pr.h)) return this.die();
        }else if(o instanceof FirePipe){
          if(o.on && o.intensity > 0.1){
            const f = o.flameRect(o.intensity);
            if(rectsOverlap(pr, f)) return this.die();
          }
        }
      }

      if(FRAME_GROUND_Y === null && this.player.y > canvas.clientHeight + 10){
        return this.die();
      }

      scorePill.textContent = `${Math.floor(this.meters)} m`;
      speedPill.textContent = `Speed ${Math.round(this.speed)}`;
    }

    die(){
      this.state = 'dead';
      const score = Math.floor(this.meters);
      if(score>hiScore){ hiScore=score; localStorage.setItem(HI_KEY, hiScore); hiPill.textContent = `HI ${hiScore} m`; }
      setOverlay(`
        <div class="banner">
          <h1>Game Over</h1>
          <p>Distance: <strong>${score} m</strong> · Top: <strong>${hiScore} m</strong></p>
          <p><button id="btnRestartGO" class="btn">Restart</button></p>
          <p><button id="btnMenuGO" class="btn">Main Menu</button></p>
        </div>`, true);
      byId('btnRestartGO').onclick = ()=> this.start();
      byId('btnMenuGO').onclick = ()=> showMenu(this);
    }

    draw(g){
      const W = canvas.clientWidth, H = canvas.clientHeight;
      g.clearRect(0,0,W,H);
      for(const seg of this.terrain) seg.draw(g);
      for(const pf of this.platforms) pf.draw(g);
      for(const o of this.obstacles) o.draw(g);
      this.player.draw(g);

      if(this.state==='playing' && this.time < 1.2){
        g.globalAlpha = 1 - this.time/1.2;
        g.fillStyle = '#fff9'; g.font = '600 18px system-ui, sans-serif';
        g.fillText('Press SPACE to jump · C/CTRL to crouch (fast-fall)', 24, 40);
        g.globalAlpha = 1;
      }
    }
  }

  // ------- Overlay helpers & Menu/Credits -------
  function byId(id){ return document.getElementById(id); }
  function setOverlay(html, active=true){
    overlay.innerHTML = html;
    overlay.classList.toggle('active', !!active);
  }
  function showMenu(inst){
    inst.state = 'menu';
    setOverlay(`
      <div class="banner">
        <h1>Endless Runner</h1>
        <p><button id="btnStart" class="btn">Start Game</button></p>
        <p><button id="btnCredits" class="btn">Credits</button></p>
      </div>`, true);
    byId('btnStart').onclick = ()=> inst.start();
    byId('btnCredits').onclick = ()=> showCredits(inst);
  }
  function showCredits(inst){
    inst.state = 'credits';
    setOverlay(`
      <div class="banner">
        <h1>Credits</h1>
        <p><!-- intentionally left empty --></p>
        <p><button id="btnBack" class="btn">Back</button></p>
      </div>`, true);
    byId('btnBack').onclick = ()=> showMenu(inst);
  }

  const world = new World();

  // ======= MAIN LOOP =======
  let last = performance.now();
  function frame(now){
    const dt = clamp((now - last)/1000, 0, 1/20);
    last = now;

    // Pause/Resume toggle always works
    if(input.pause){
      if(world.state==='playing') world.pause();
      else if(world.state==='paused') world.resume();
      input.pause = false;
    }

    // Restart key
    if(input.restart){
      input.restart=false;
      if(world.state==='menu' || world.state==='credits'){ world.start(); }
      else { world.start(); }
    }

    world.update(dt);
    world.draw(ctx);

    requestAnimationFrame(frame);
  }
  requestAnimationFrame(frame);

  function byId(id){ return document.getElementById(id); }

  // Click-to-focus for keyboard on some browsers
  canvas.addEventListener('click', ()=> canvas.focus && canvas.focus());
  </script>
</body>
</html>
